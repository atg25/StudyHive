// CS101 demo data
var sampleData = {
  cs101: {
    notes: "Binary Search Algorithm - CS 101 Lecture Notes\n\nDefinition: Binary search is a searching algorithm that finds the position of a target value within a sorted array.\n\nKey Concepts:\n- Divide and conquer approach\n- Works only on sorted arrays\n- Compares target value to middle element\n- Eliminates half of remaining elements each iteration\n\nTime Complexity:\n- Best case: O(1)\n- Average case: O(log n)\n- Worst case: O(log n)\n\nAlgorithm Steps:\n1. Find middle element\n2. If target equals middle, return index\n3. If target < middle, search left half\n4. If target > middle, search right half\n5. Repeat until found or subarray empty",

    summary: "**Binary Search: Complete Study Guide**\n\nBinary search is a highly efficient divide-and-conquer algorithm for finding elements in sorted arrays. It achieves O(log n) time complexity by eliminating half the search space with each comparison, making it exponentially faster than linear search for large datasets.\n\n**Core Algorithm:**\n1. Start with left=0, right=array.length-1\n2. Calculate mid = left + (right-left)/2 (prevents integer overflow)\n3. Compare array[mid] with target value\n4. If target equals array[mid], element found - return index\n5. If target is less than array[mid], search left half (right = mid-1)\n6. If target is greater than array[mid], search right half (left = mid+1)\n7. Repeat steps 2-6 until element found or left > right\n\n**Why Binary Search is Powerful:**\nThe logarithmic time complexity means binary search scales incredibly well. For an array of 1,000 elements, binary search needs at most 10 comparisons (log₂ 1000 ≈ 10), while linear search could need up to 1,000 comparisons. For 1 million elements, binary search needs only 20 comparisons versus potentially 1 million for linear search!\n\n**Key Requirements:**\n- Array MUST be sorted in ascending or descending order\n- Random access to elements (works with arrays, not linked lists)\n- Elements must be comparable\n- Unsorted data will produce incorrect results\n\n**Time and Space Complexity:**\n- Time: O(log n) average and worst case, O(1) best case (element at middle)\n- Space: O(1) for iterative implementation, O(log n) for recursive (call stack)\n- Iterative approach preferred in practice for space efficiency\n\n**Step-by-Step Example:**\nFinding 67 in [2, 5, 8, 12, 16, 23, 38, 45, 56, 67, 78]\n\nIteration 1:\n- left=0, right=10, mid=5\n- array[5]=23, which is less than 67\n- Search right half: left=6\n\nIteration 2:\n- left=6, right=10, mid=8\n- array[8]=56, which is less than 67\n- Search right half: left=9\n\nIteration 3:\n- left=9, right=10, mid=9\n- array[9]=67, which equals target\n- Found! Return index 9\n\nOnly 3 comparisons needed instead of potentially 10 with linear search.\n\n**Real-World Applications:**\n1. **Database Systems:** Index searching for fast record retrieval in B-trees\n2. **Spell Checkers:** Dictionary lookups in sorted word lists\n3. **Version Control:** Git bisect finds bugs by binary searching commit history\n4. **Game Development:** Collision detection in sorted object lists\n5. **File Systems:** Directory structures and file searching\n6. **Networking:** IP routing tables and DNS lookups\n7. **Machine Learning:** Feature selection and hyperparameter tuning\n\n**Comparison with Other Algorithms:**\n- **Linear Search:** O(n) time, works on unsorted data, simpler implementation\n- **Hash Tables:** O(1) average lookup but requires O(n) extra space\n- **Jump Search:** O(√n) time, good middle ground for certain scenarios\n- **Interpolation Search:** O(log log n) for uniformly distributed data\n- Binary search is optimal for sorted data with multiple queries\n\n**Common Implementation Mistakes:**\n1. **Integer Overflow:** Always use mid = left + (right-left)/2 instead of (left+right)/2\n2. **Infinite Loops:** Ensure left or right updates in every iteration\n3. **Off-by-One Errors:** Use while (left <= right) not while (left < right)\n4. **Forgetting to Sort:** Always verify array is sorted before applying binary search\n5. **Wrong Comparison:** Make sure comparison logic matches sort order\n\n**Advanced Variants:**\n- **Finding First/Last Occurrence:** Modified binary search for duplicates\n- **Finding Insertion Point:** Locate where to insert element maintaining sort\n- **Rotated Array Search:** Binary search on arrays rotated at unknown pivot\n- **2D Matrix Search:** Apply binary search principles to sorted matrices\n- **Binary Search on Answer Space:** Optimize problems by searching solution space\n\n**Interview Tips:**\nBinary search is extremely common in technical interviews. Practice:\n- Standard implementation (both iterative and recursive)\n- Finding boundaries in arrays with duplicates\n- Searching in rotated or modified arrays\n- Recognizing when to apply binary search to non-obvious problems\n- Edge cases: empty arrays, single elements, target at boundaries\n\n**Best Practices:**\n- Always test edge cases thoroughly\n- Use standard library functions when available (C++ lower_bound/upper_bound, Python bisect)\n- Add input validation in production code\n- Consider using iterative over recursive for space efficiency\n- Document preconditions (sorted array requirement) clearly\n\n**Key Takeaway:**\nBinary search is fundamental to computer science and appears everywhere from databases to machine learning. Its O(log n) performance makes it indispensable for large datasets. Master this algorithm - understanding binary search deeply will help you recognize optimization opportunities throughout your programming career.",

    flashcards: [
      {
        q: "What is binary search?",
        a: "A searching algorithm that finds a target value in a sorted array using divide-and-conquer"
      },
      {
        q: "What is the time complexity of binary search?",
        a: "O(log n)"
      },
      {
        q: "What is required for binary search to work?",
        a: "The array must be sorted"
      },
      {
        q: "How does binary search eliminate elements?",
        a: "By comparing to the middle element and eliminating half the remaining elements each iteration"
      }
    ]
  }
};
